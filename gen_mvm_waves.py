# Generate MVM waves with harbingers and such
# The actual .pop file has tons of redundancy, which means editing it is tedious.

# Default amounts of money per wave (can be changed per-wave)
WAVE_MONEY = 500 # Money from regular waves
HARBINGER_MONEY = 100 # Money from the harbingers in tank waves
TANK_MONEY = 500 # Money from the tanks themselves
SUPPORT_MONEY = 100 # Total money spread across all support bots of each type

# Don't know what of this would be different for different maps
PREAMBLE = """//This file was generated by gen_mvm_waves.py
#base robot_giant.pop
#base robot_standard.pop
#base robot_gatebot.pop
"""

TEMPLATES = {
		"Anorexic_Heavy": {
			"Health": 100,
			"Name": "Heavy",
			"Class": "HeavyWeapons",
			"Skill": "Normal",
			"WeaponRestrictions": "SecondaryOnly",
			"Item": ["tf_weapon_minigun", "tf_weapon_shotgun_hwg", "tf_weapon_fists"],
		},
		"T_TFBot_Heavy": {
			"Health": 300,
			"Name": "Heavy",
			"Class": "HeavyWeapons",
			"Skill": "Normal",
			"Item": ["tf_weapon_minigun", "tf_weapon_shotgun_hwg", "tf_weapon_fists"],
		},
		"BOSS_ReflectMe": {
			"Health": 250000,
			"Name": "Reflect Me",
			"Class": "Soldier",
			"Skill": "Normal",
			"WeaponRestrictions": "PrimaryOnly",
			"Attributes": ["AlwaysCrit", "MiniBoss"],
			"Item": ["the original", "tf_weapon_shotgun_soldier", "tf_weapon_shovel"],
			"CharacterAttributes": {
				"Projectile speed decreased": 0.75,
				"damage bonus": 10,
				"dmg falloff decreased": 1,
				"move speed penalty": 0.15,
				"airblast vulnerability multiplier": 0,
				"damage force reduction": 0,
				"cannot pick up intelligence": 1,
			}
		},
		"T_TFBot_Demoman_Boom": {
			"Health": 175,
			"Name": "Demoman",
			"Class": "Demoman",
			"Skill": "Normal",
			"Item": [
				"tf_weapon_grenadelauncher",
				"tf_weapon_pipebomblauncher",
				"the ullapool caber",
				"scotsman's stove pipe",
				"ttg glasses",
			],
			"CharacterAttributes": {
				"health regen": 5,
			}
		}
	}

class Wave:
	"""Singleton just to allow 'with wave:' constructs"""
	def __enter__(self):
		pop.write("Wave", {
			"WaitWhenDone": 65,
			"Checkpoint": "Yes",
			"StartWaveOutput": {
				"Target": "wave_start_relay",
				"Action": "Trigger",
			},
			"DoneOutput": {
				"Target": "wave_finished_relay",
				"Action": "Trigger",
			}
		}, autoclose=False)
		self.money = self.subwaves = 0
	def __exit__(self, t, v, tb):
		pop.close()
		# The maximum possible money after a wave includes a 100-credit bonus.
		pop.total_money += self.money + 100
		print("Wave money:", self.money, "+ 100 ==> cumulative", pop.total_money)
wave = Wave()

def subwave(botclass, count, *, max_active=5, spawn_count=2, money=WAVE_MONEY, chain=False):
	wave.subwaves += 1
	pop.write("WaveSpawn", {
		"Name": f"Subwave {wave.subwaves}",
		"WaitForAllSpawned": f"Subwave {wave.subwaves-1}" if chain else None,
		"TotalCurrency": money,
		"TotalCount": count,
		"MaxActive": max_active,
		"SpawnCount": spawn_count,
		"Where": "spawnbot",
		"WaitBeforeStarting": 0,
		"WaitBetweenSpawns": 10,
		"Squad": {"TFBot": {"Template": botclass}},
	})
	wave.money += money

def harby_tanks(count, harby_money=HARBINGER_MONEY, tank_money=TANK_MONEY):
	# TODO: Make the names unique within a wave, such that calling
	# this function more than once results in parallel chains of
	# harbingers and tanks (muahahahahaha)
	for i in range(count):
		# Add the harbinger. The first one is a little bit different.
		pop.write("WaveSpawn", {
			"Name": f"Harbinger {i + 1}",
			"WaitForAllDead": f"Harbinger {i}" if i else None,
			"TotalCurrency": harby_money,
			"TotalCount": 1,
			"Where": "spawnbot",
			"WaitBeforeStarting": 30 if i else 0,
			"Squad": {"TFBot": {
				"Health": 500,
				"Name": "Soldier",
				"Class": "Soldier",
				"Skill": "Normal",
				"Item": ["tf_weapon_rocketlauncher", "tf_weapon_shotgun_soldier", "tf_weapon_shovel"],
			}},
		})
		# And add the tank itself.
		pop.write("WaveSpawn", {
			"Name": f"Tank {i + 1}",
			"WaitForAllDead": f"Harbinger {i + 1}",
			"TotalCurrency": tank_money,
			"TotalCount": 1,
			"Where": "spawnbot",
			"WaitBeforeStarting": 0,
			"Squad": {"Tank": {
				"Health": 40000,
				"Name": "Tank",
				"Speed": 75,
				"StartingPathTrackNode": "boss_path_1",
				"OnKilledOutput": {
					"Target": "boss_dead_relay",
					"Action": "Trigger",
				},
				"OnBombDroppedOutput": {
					"Target": "boss_deploy_relay",
					"Action": "Trigger",
				}
			}},
		})
		wave.money += harby_money + tank_money

def support(*botclasses, money=SUPPORT_MONEY, max_active=5, spawn_count=2):
	for botclass in botclasses:
		pop.write("WaveSpawn", {
			"TotalCurrency": money,
			"TotalCount": 10, # With support waves, I think this controls the money drops
			"MaxActive": max_active,
			"SpawnCount": spawn_count,
			"Where": "spawnbot",
			"WaitBeforeStarting": 0,
			"WaitBetweenSpawns": 10,
			"Support": 1,
			"Squad": {"TFBot": {"Template": botclass}},
		})
		wave.money += money

class PopFile:
	def __init__(self, fn, **kw):
		self.fn = fn
		self.__dict__.update(kw)
	def __enter__(self):
		self.file = open(self.fn, "w")
		print("Starting:", self.fn)
		print("Starting money:", self.starting_money)
		print(PREAMBLE, file=self.file)
		self.total_money = self.starting_money
		self.indentation = 0
		self.write("population", {
			"StartingCurrency": self.starting_money,
			"RespawnWaveTime": 6,
			"CanBotsAttackWhileInSpawnRoom": "no",
			"Templates": TEMPLATES,
		}, autoclose=False)
		return self
	def __exit__(self, t, v, tb):
		while self.indentation:
			self.close()
		print("Total money after all waves:", self.total_money)
		self.file.close()
		self.file = None
		print("Completing:", self.fn)
	def write(self, key, obj, autoclose=True):
		"""Write an object to the 'pop' file.

		If autoclose is True, will end the block cleanly, leaving us at the
		same indentation level we were previously at. Otherwise, the final
		closing brace will be omitted, allowing subsequent write() calls
		to continue the current object.
		"""
		if obj is None: return # Allow "sometimes there, sometimes not" entries in dicts/lists
		indent = "\t" * self.indentation
		if " " in key and not key.startswith('"'):
			# Keys and string values with spaces in them get quoted.
			key = '"' + key + '"'
		if isinstance(obj, dict):
			print(indent + key, file=self.file)
			print(indent + "{", file=self.file)
			self.indentation += 1
			for k, v in obj.items():
				self.write(k, v)
			if autoclose:
				self.close()
		elif isinstance(obj, (list, tuple)):
			for val in obj:
				self.write(key, val)
		else:
			# Should normally be a string, integer, float, or similar
			# simple type.
			obj = str(obj)
			# If there's a space in the value, it gets quoted for safety.
			if " " in obj:
				obj = '"' + obj + '"'
			print(indent + key + "\t" + obj, file=self.file)

	def close(self):
		"""Close an object that was written with autoclose=False"""
		self.indentation -= 1
		print("\t" * self.indentation + "}", file=self.file)

# The starting money also functions as a sort of version number
with PopFile("mvm_coaltown.pop", starting_money=1510) as pop:
	with wave:
		subwave("T_TFBot_Scout_Fish", 10, money=100)
		subwave("Anorexic_Heavy", 25, money=250, chain=True)
		subwave("T_TFBot_Demoman", 15, money=150)
		subwave("T_TFBot_Pyro", 5, money=50, chain=True)
	with wave:
		harby_tanks(1)
		support("T_TFBot_Scout_Scattergun_SlowFire")
	with wave:
		harby_tanks(2)
		subwave("T_TFBot_Demoman", 10)
		support("T_TFBot_Heavy", "T_TFBot_Sniper")
	with wave:
		harby_tanks(3)
		subwave("T_TFBot_Pyro", 20, max_active=10, spawn_count=4)
		subwave("T_TFBot_Medic", 10)
		support("T_TFBot_Scout_Fish")
	with wave:
		harby_tanks(5)
		subwave("T_TFBot_Sniper", 25, max_active=10, spawn_count=5)
		support("T_TFBot_Heavyweapons_Fist", "T_TFBot_Demoman_Boom")
	with wave:
		subwave("BOSS_ReflectMe", 1)
		subwave("T_TFBot_Demoman_Knight", 50, max_active=10, spawn_count=5)
		support("T_TFBot_Sniper_Huntsman", "T_TFBot_Pyro", spawn_count=1)
